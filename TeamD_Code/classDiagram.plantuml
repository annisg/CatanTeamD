@startuml
'Getters, setters and some other methods are excluded for simplicity'

package model
{
    class CandidateRoadFinder
    {
        +CandidateRoadFinder(board: GameMap)
        ~getCandidateRoadFromEdge(edge: Edge): CandidateRoad
        ~edgeRecurse(edge: Edge, visitedEdges: Edge[*], visitedIntersections: Intersection[*]): CandidateRoad
        -intersectionRecurse(intersection: Intersection, visitedEdges: Edge[*], visitedIntersections: Intersection[*]): CandidateRoad
        -edgeIsVisitable(edge: Edge, visitedEdges: Edge[*], originalColor: PlayerColor): boolean
        -intersectionNotBlocked(intersection: Intersection, originalColor: PlayerColor): boolean
    }
    CandidateRoadFinder --> GameMap: board
    CandidateRoadFinder --> Edge
    CandidateRoadFinder --> Intersection

    abstract class DevelopmentCard
    {
        -canBePlayed: boolean
        +{abstract}getName(): String
        +{abstract}use(Player owner): void
        +canBePlayed(): boolean
        +makePlayable(): void
    }
    DevelopmentCard --> Player

    class DevelopmentDeck
    {
        +DevelopmentCard(largestArmy: LargestArmy)
        +DevelopmentCard(largestArmy: LargestArmy, random: Random)
        -populateDeck(): void
        +populateDeckUniqueCards(): void
        +size(): int
        +drawCard(): DevelopmentCard
    }
    DevelopmentCard --> DevelopmentCard: cards[*]
    DevelopmentCard --> LargestArmy: largestArmy

    class EdgeMap
    {
        -edges: Edge[11][*]
        +EdgeMap()
        +getAllAdjacentIntersections(givenEdge: Edge): MapPosition[*]
        +getAllAdjacentIntersections(edgePosition: MapPosition): MapPosition[*]
        +getAdjacentIntersection(givenEdge: Edge, givenDirection: Direction): MapPosition
        +getIntersectionDirection0(givenEdge: Edge): MapPosition
        +getIntersectionDirection0(edgePosition: MapPosition): MapPosition
        +getIntersectionDirection1(givenEdge: Edge): MapPosition
        +getIntersectionDirection1(edgePosition: MapPosition): MapPosition
        +getEdge(position: MapPosition): Edge
        +getClosestEdgeToPoint(point: Point): Edge
        -getDistanceFromPoint(mapPosition: MapPosition, point: Point): double
        +findEdgePosition(givenEdge: Edge): MapPosition
        +getNumberOfEdgesInRow(rowNumber: int): int
        -isNotValidPosition(positionToTest: MapPosition): boolean
        -isNotValidRow(rowNumber: int): boolean
        +getNumberOfRows(): int
        -isInBottomHalf(pos: MapPosition): boolean
        -isInTopHalf(pos: MapPosition): boolean
    }
    EdgeMap --> MapPosition

    class GameMap
    {
        +GameMap()
        +setUpBeginnerMap(numPlayers: int): void
        +setUpAdvancedMap(): void
        +setUpCustomPorts(): void
        +getHex(row: int, col: int): Hex
        +getIntersection(row: int, col: int): Intersection
        +getClosestEdgeToPoint(point: Point): Edge
        +getClosestIntersectionToPoint(point: Point): Intersection
        +getEdge(row: int, col: int): Edge
        +moveRobberToClosestHex(mousePosition: Point): void
        +getClosestValidRobberPosition(mosePosition: Point): MapPosition
        -placeBeginnerPieces(numPlayers: int): void
        +getHexesByResourceNumber(resourceNumber: int): Hex[*]
        +getPortFromIntersection(givenIntersection: Intersection): Port
        +getPortFromIntersection(intersectionPos: MapPosition): Port
        +getSpecificHexFromIntersection(givenIntersection: Intersection, givenDirection: Direction)
        +getAllHexesFromIntersection(givenIntersection: Intersection): Hex[*]
        +getAllHexesFromIntersection(intersectionRow: int, intersectionCols: int): Hex[*]
        +getSpecificEdgeFromIntersection(givenIntersection: Intersection, givenDirection: Direction): edge
        +getAllEdgesFromIntersection(givenIntersection: Intersection): Edge[*]
        +getAllEdgesFromIntersection(intersectionRow: int, intersectionCol: int): Edge[*]
        +getSpecificIntersectionFromEdge(givenEdge: Edge, intersectionDirection: Direction): Intersection
        +getAllIntersectionsFromEdge(givenEdge: Edge): Intersection[*]
        +getAllIntersectionsFromEdge(edgeRow: int, edgeCol: int): Intersection[*]
        +getSpecificIntersectionFromHex(givenHex: Hex, intersectionDirection: Direction): Intersection
        +getAllIntersectionsFromHex(givenHex: Hex): Intersection[*]
        +getAllIntersectionsFromHex(hexRow: int, hexCol: int): Intersection[*]
        +canSeeIntersection(givenIntersection: Intersection, color: PlayerColor): boolean
        +canSeeEdge(givenEdge: Edge, color: PlayerColor): boolean
        +doesPlayerOwnsGenericHarbor(currentPlayer: Player): boolean
        +doesPlayerOwnsSpecialHarbor(currentPlayer: Player, resource: Resource)
    }
    GameMap --> HexMap: hexMap
    GameMap --> IntersectionMap: intersectionMap
    GameMap --> EdgeMap: edgeMap
    GameMap --> PortMap: portMap
    GameMap --> Hex
    GameMap --> Intersection
    GameMap --> Edge
    GameMap --> MapPosition

    class Hex
    {
        -providesResource: Resource
        -rollResourceNumber: int
        ~hasRobber: boolean
        +Hex(providesResource: Resource, rollResourceNumber: int)
        +Hex()
        +placeRobber(): void
        +removeRobber(): void
        +getResource(): Resource
        +getRollResourceNumber(): int
        +hasRobber(): boolean
    }

    class HexMap
    {
        -resourceHashMap: HashMap<Integer, Hex[*]>
        +HexMap()
        +getHex(hexPosition: MapPosition): Hex
        +getHexesByResourceNumber(resourceNumber: int): Hex[*]
        +moveRobberToPosition(newRobberPosition: MapPosition): void
        +getAllAdjacentIntersections(givenHex: Hex): MapPosition[*]
        +getAllAdjacentIntersections(hexPosition: MapPosition): MapPosition[*]
        +getAdjacentIntersection(givenHex: Hex, givenDirection: Direction): MapPosition
        +getAdjacentIntersection(hexPosition: MapPosition, givenDirection: Direction): MapPosition
        +getIntersectionDirection0(hexPosition: MapPosition): MapPosition
        +getIntersectionDirection1(hexPosition: MapPosition): MapPosition
        +getIntersectionDirection2(hexPosition: MapPosition): MapPosition
        +getIntersectionDirection3(hexPosition: MapPosition): MapPosition
        +getIntersectionDirection4(hexPosition: MapPosition): MapPosition
        +getIntersectionDirection5(hexPosition: MapPosition): MapPosition
        -isInvalidResourceNumber(resourceNumber: int): boolean
        -isInvalidHexPosition(posToCheck): boolean
        +findHexPosition(givenHex: Hex): MapPosition
        +setUpAdvancedMap(random: Random): void
        +setUpCustomMap(resources: Resource[*], resourceNumber: int): void
        +getShuffledResourceNumbers(random: Random): int[*]
        +getStandardResourceNumbers(): int[*]
        +getShuffledResources(random: Resource): Resource[*]
        +getStandardResources(): Resource[*]
        +setUpBeginnerMap(): void
        -populateResourceNumberHashMap(): void
        -placeHexArrayOneMap(hexes: Hex[*])
        -isInBottomHalf(pos: MapPosition): boolean
        -isInTopHalf(pos: MapPosition): boolean
        +getNumberOfHexesInRow(n: int): int
        +getClosestValidRobberPosition(mousePosition: Point): MapPosition
        -getHexPosition(mapPosition: MapPosition): Point
    }
    HexMap --> Hex: hexes[5][0]
    HexMap --> Robber: robber

    class Intersection
    {

    }

    class IntersectionMap
    {

    }

    class LargestArmy
    {

    }

    class LongestRoad
    {

    }

    class MapPosition
    {

    }

    class PieceBuilder
    {

    }

    class Player
    {

    }

    class PlayerColor
    {

    }

    interface Port
    {

    }

    class PortMap
    {

    }

    class PropertyPlacer
    {

    }

    class ResourceProducer
    {

    }

    class Robber
    {

    }

    class SpecificPort
    {

    }

    class TurnTracker
    {

    }

    class VictoryPointCalculator
    {

    }
}

package control
{
    class BuildingHandler
    {
        +BuildingHandler(game: CatanGame, builder: PieceBuilder, handler: InputHandler)
        ~placeInitialSettlement(point: Point): void
        ~placeInitialRoadAtClosestEdge(point: Point): void
        +placeSettlement(point: Point): void
        +placeCity(point: Point): void
        +placeRoad(point: Point, chargeResources: boolean): void
        +buyDevelopmentCard((hasNotRolled: boolean): void
    }
    BuildingHandler --> CatanGame: catanGame
    BuildingHandler --> PieceBuilder: itemBuilder
    BuildingHandler --> InputHandler: handler

    class CatanGame
    {
        -isFogOfWar: boolean
        +CatanGame()
        ~startGame(): void
        +makeBoard(state: GameStartState, numPlaers: int, gamemode: GameMode, isDebug: boolean): void
        +advancedInitialPlacement(): void
        -customHexPlacement(): void
        +drawScreen(): void
        +drawMap(): void
        +drawPlayers(): void
        +drawSpecialCards(): void
        +endTurn(): void
    }
    CatanGame --> GameBoard: gui
    CatanGame --> InputComponenet: input
    CatanGame --> GameMap: model
    CatanGame --> HexPlacer: hexesAndHexNumPlacer
    CatanGame --> PlayerPlacer: playerPlacer
    CatanGame --> TurnTracker: turnTracker
    CatanGame --> GameOptionSelector: options
    CatanGame --> MaritimeTradeManager: maritimeTradeManager
    CatanGame --> InputHandler: inputHandler
    CatanGame --> VictoryPointCalculator: pointCalculator
    CatanGame --> LongestRoad
    CatanGame --> LargestArmy
    CatanGame --> PieceBuilder
    CatanGame --> PropertyPlacer
    CatanGame --> DevelopmentDeck

    class HexPlacer
    {
        -{static}height: int
        -{static}heightOffset: int
        -{static}widthOffset: int
        -{static}leftMin: int
        +HexPlacer(hexes: HexMap)
        +getAllDrawables(): Drawable[*]
        ~getHexDrawable(hexObject: Hex, row: int, col: int): HexGUI
        ~getHexNumDrawable(hexObject: Hex, row: int, col: int): HexNumGUI
        +{static}calculatePosition(row: int, col: int): int[*]
    }
    HexPlacer --> HexMap: hexes
    HexPlacer --> Hex
    HexPlacer --> HexGUI
    HexPlacer --> HexNumGUI

    class InputHandler
    {
        ~hasNotRolled: boolean
        -hexPlacementNumbers: int[*]
        -hexPlacementResources: Resource[*]
        +InputHandler(resourceProducer: ResourceProducer, game: CatanGame, builder: PieceBuilder)
        +buyDevelopmentCard(): void
        +selectAndUseDevCard(): void
        ~playDevelopmentCard(selected: Class): void
        -stealAllOfResource(resource: Resource): void
        +discardCardsForEveryPlayer(): void
        +tradeWithPlayer(): void
        +rollDice(): int
        -moveRobber(): void
        ~selectPlayerToStealFromAtMapPosition(mapPosition: MapPosition): void
        +produceResources(numRolled: int): void
        -stealFromPlayer(selectedPlayerColor: PlayerColor): void
        -offerPlayerTwoFreeRoads(): void
        -giveResourceToCurrentPlayer(resource: Resource): void
        ~updateRobberPositionOnBoard(mousePosition: Point): void
        +endTurn(): void
    }
    InputHandler --> Select1Frame: devCardSelector, resourceNumberSelector, resourceSelector, resourceSelector2
    InputHandler --> Select2Frame: optionalIntersectionSelector, optionalEdgeSelector, mandatoryIntersectionSelector, mandatoryEdgeSelector, hexSelector
    InputHandler --> BuildingHandler: propertyBuilder
    InputHandler --> ResourceProducer: resourceProducer
    InputHandler --> CatanGame: catanGame
    InputHandler --> PieceBuilder

    class MaritimeTradeManager
    {
        +{static} DEFAULT_TRADE_COST: int
        +{static} GENERIC_TRADE_COST: int
        +{static} SPECIAL_TRADE_COST: int
        -soldResource: Resource
        -boughtResource: Resource
        +MaritimeTradeManager(inputHandler: InputHandler, catanGame: CatanGame)
        +trade(): void
        ~sellResource(resource: Resource): void
        ~buyResource(resource: Resource): void
        ~tradeViaPort(portType: PortSelector.PortTypes): void
        ~exchangeResourcesWithBand(tradeCost: int): void
    }
    MaritimeTradeManager --> InputHandler: inputHandler
    MaritimeTradeManager --> CatanGame: catanGame
    MaritimeTradeManager --> ResourceSelector: sellingResourceSelector, buyingResourceSelector
    MaritimeTradeManager --> PortSelector: portSelector

    class PlayerPlacer
    {
        -xPlayerBackground: int
        -yPlayerBackground: int
        -playerBackgroundWidth: int
        -playerBackgroundHeight: int
        ~numberOfPlayers: int
        +PlayerPlacer(turnTracker: TurnTracker)
        +refreshPlayerNumber(): void
        +getAllPlayerGUIs(): Drawable[*]
        +getDevelopmentCardMap(player: Player): HashMap<String, int>
        +getDevelopmentCardMapAmount(player: Player): HashMap<String, int>
    }
    PlayerPlacer --> turnTracker: turnTracker
    PlayerPlacer --> Player
}
@enduml