@startuml
'Greatly reduced for readability'

package gui
{

    abstract class Drawable
    {
        ~xCoord: int
        ~yCoord: int
        +drawComponent(g: Graphics)
        +{abstract} getShape(): Shape
    }

    class DrawablePort extends Drawable
    {
        +DrawablePort(prot: Port, pos: MapPosition, x: int, y: int)
    }
    DrawablePort --> Port: port
    DrawablePort --> MapPosition: position

    class EdgeGUI extends Drawable
    {
        ~direction: EdgeDirection
        EdgeGUI(playerColor: PlayerColor, x: int, y: int, direction: EdgeDirection)
    }

    class GameBoard
    {
        +fullResetMap(): void
        +drawFullMap(): void
        drawProperty(): void
        +clearScreen(): void
        +drawIntersections(): void
        +drawEdges(): void
        ~paintComponent(g: Graphics): void
        -drawObjects(g: Graphics, objects: Drawable[*]): void
        +showPopup(): void
    }
    GameBoard --> Drawable: hexesAndNumbersToDraw[*], propertyToDraw[*], playersToDraw[*], portsToDraw[*]

    class GameOptionSelector
    {
        -selectedState: GameStartState
        -selectedGameMode: GameMode
        -numPlayers: int
        +getOptionsFromUser(catanController: CatanGame): void
    }

    class HexGUI extends Drawable
    {
        resourceToColor: Resource
        +HexGUI(resource: Resource, x: int, y: int)
    }

    class HexNumGUI extends Drawable
    {
        ~num: int
        +HexNumGUI(num: int, x: int, y: int, hasRobber: boolean)
    }

    class InputComponent
    {
        -clickFunctionQueue: Queue<ClickFunctionAndDisplayString>
        +InputComponent(handler: InputHandler, maritimeTradeManager: MaritimeTradeManager)
        ~{static} rollDiceClicked(handler: InputHandler, rollDiceButton: JButton, buyDevCard: JButton, useDevCard: JButton, endTurn: JButton): void
        ~endTurnClicked(handler: InputHandler, rollDiceButton: JButton, buyDevCard: JButton, useDevCard: JButton, endTurn: JButton): void
        +addMouseListenerToParent(): void
        +placeRoadWithCard(): void
        -addToQueueAndUpdateNextClickActionText(clickFunctionAndDisplayString: ClickFunctionAndDisplayString): void
        -updateNextActionLabel(): void
        +addMoveRobberToQueue(): void
    }
    InputComponent --> InputHandler: handler
    InputComponent --> MaritimeTradeManager: maritimeTradeManager

    class PlayerGUI extends Drawable
    {
        -numOfEachResource: HashMap<Resource, int>
        -numOfEachDevelopmentCard: HashMap<String, int>
        ~playerPosition: int
        -playerName: String
        +PlayerGUI(colorOfPlayer: Color, numPerResourceMap: HashMap<Resource, int>, numOfEachDevelopmentCard: HashMap<String, int>, position: int, playerOrder: int, playerName: String)
        -drawPlayerName(g2: Graphics2D): void
        -drawDevelopmentCards(g2: Graphics2D): void
        -drawResourceCards(g2: Graphics2D): void
    }

    class RemoveCardsGUI
    {

    }

    class Select1Frame
    {

    }

    class Select2Frame
    {

    }

    abstract class SelectFrame
    {

    }

    class SettlementGUI extends Drawable
    {
        +SettlementGUI(playerColor: PlayerColor, x: int, y: int, rotate: boolean)
    }

    class SpecialCardGUI extends Drawable
    {
        ~order: int
        ~cardName: String
        +SpecialCardGUI(cardName: String, holderColor: Color, order: int)
    }

    class TradeWithSpecificPlayerGUI
    {

    }
}

package model
{
    class CandidateRoadFinder
    {
        +CandidateRoadFinder(board: GameMap)
        ~getCandidateRoadFromEdge(edge: Edge): CandidateRoad
        ~edgeRecurse(edge: Edge, visitedEdges: Edge[*], visitedIntersections: Intersection[*]): CandidateRoad
        -intersectionRecurse(intersection: Intersection, visitedEdges: Edge[*], visitedIntersections: Intersection[*]): CandidateRoad
        -edgeIsVisitable(edge: Edge, visitedEdges: Edge[*], originalColor: PlayerColor): boolean
        -intersectionNotBlocked(intersection: Intersection, originalColor: PlayerColor): boolean
    }
    CandidateRoadFinder --> GameMap: board
    CandidateRoadFinder --> Intersection

    abstract class DevelopmentCard
    {
        -canBePlayed: boolean
        +{abstract}getName(): String
        +{abstract}use(Player owner): void
        +canBePlayed(): boolean
        +makePlayable(): void
    }
    DevelopmentCard --> Player

    class DevelopmentDeck
    {
        +DevelopmentCard(largestArmy: LargestArmy)
        +DevelopmentCard(largestArmy: LargestArmy, random: Random)
        -populateDeck(): void
        +size(): int
        +drawCard(): DevelopmentCard
    }
    DevelopmentCard --> DevelopmentCard: cards[*]
    DevelopmentCard --> LargestArmy: largestArmy

    class EdgeMap
    {
        -edges: Edge[11][*]
        +getAllAdjacentIntersections(givenEdge: Edge): MapPosition[*]
        +getAdjacentIntersection(givenEdge: Edge, givenDirection: Direction): MapPosition
        +getIntersectionDirection0(givenEdge: Edge): MapPosition
        +getIntersectionDirection1(givenEdge: Edge): MapPosition
        +getEdge(position: MapPosition): Edge
        +getClosestEdgeToPoint(point: Point): Edge
        +findEdgePosition(givenEdge: Edge): MapPosition
        +getNumberOfEdgesInRow(rowNumber: int): int
    }
    EdgeMap --> MapPosition

    class GameMap
    {
        +setUpBeginnerMap(numPlayers: int): void
        +setUpAdvancedMap(): void
        +setUpCustomPorts(): void
        +getClosestEdgeToPoint(point: Point): Edge
        +getClosestIntersectionToPoint(point: Point): Intersection
        +moveRobberToClosestHex(mousePosition: Point): void
        +getHexesByResourceNumber(resourceNumber: int): Hex[*]
        +getPortFromIntersection(givenIntersection: Intersection): Port
        +getSpecificHexFromIntersection(givenIntersection: Intersection, givenDirection: Direction)
        +getSpecificEdgeFromIntersection(givenIntersection: Intersection, givenDirection: Direction): edge
        +getSpecificIntersectionFromEdge(givenEdge: Edge, intersectionDirection: Direction): Intersection
        +getSpecificIntersectionFromHex(givenHex: Hex, intersectionDirection: Direction): Intersection
        +canSeeIntersection(givenIntersection: Intersection, color: PlayerColor): boolean
        +canSeeEdge(givenEdge: Edge, color: PlayerColor): boolean
        +doesPlayerOwnsGenericHarbor(currentPlayer: Player): boolean
        +doesPlayerOwnsSpecialHarbor(currentPlayer: Player, resource: Resource): boolean
    }
    GameMap --> HexMap: hexMap
    GameMap --> IntersectionMap: intersectionMap
    GameMap --> EdgeMap: edgeMap
    GameMap --> PortMap: portMap
    GameMap --> Hex
    GameMap --> Intersection
    GameMap --> MapPosition

    class Hex
    {
        -providesResource: Resource
        -rollResourceNumber: int
        ~hasRobber: boolean
        +Hex(providesResource: Resource, rollResourceNumber: int)
        +placeRobber(): void
        +removeRobber(): void
        +getRollResourceNumber(): int
    }

    class HexMap
    {
        -resourceHashMap: HashMap<Integer, Hex[*]>
        -robber: Robber
        +getHex(hexPosition: MapPosition): Hex
        +moveRobberToPosition(newRobberPosition: MapPosition): void
        +getAdjacentIntersection(givenHex: Hex, givenDirection: Direction): MapPosition
        +setUpAdvancedMap(random: Random): void
        +setUpCustomMap(resources: Resource[*], resourceNumber: int): void
        +setUpBeginnerMap(): void
        -populateResourceNumberHashMap(): void
        +getClosestValidRobberPosition(mousePosition: Point): MapPosition
        -getHexPosition(mapPosition: MapPosition): Point
    }
    HexMap --> Hex: hexes[5][0]

    class Intersection
    {
        -hasSettlement: boolean
        -hasCity: boolean
    }
    Intersection --> Port: port

    class IntersectionMap
    {
        +getAdjacentHex(givenIntersection: Intersection, givenDirection: Direction): MapPosition
        +getAdjacentEdge(givenIntersection: Intersection, givenDirection: Direction): MapPosition
        +getClosestIntersectionToPoint(point: Point): Intersection
        +findIntersectionPosition(knownIntersection: Intersection): MapPosition
        +doesPlayerOwnsGenericHarbor(player: Player): boolean
        +doesPlayerOwnsSpecialHarbor(player: Player, resource: Resource): boolean
    }
    IntersectionMap --> Intersection: intersectionMap[*][*]
    IntersectionMap --> MapPosition
    IntersectionMap --> Player

    class LargestArmy
    {
        -size: int
        +LargestArmy(players: TurnTracker)
        +updateLargestArmy(): void
    }
    LargestArmy --> TurnTracker: turnTracker

    class LongestRoad
    {
        +currentLongestRoad: CandidateRoad
        +LongestRoad(candidateRoadFinder: CandidateRoadFinder)
        +updateLongestRoad(board: GameMap): void
    }
    LongestRoad --> CandidateRoadFinder: candidateRoadFinder
    LongestRoad --> GameMap

    class MapPosition
    {
        -row: int
        -col: int
        +MapPosition(row: int, column: int)
        +MapPosition()
        +setPosition(row: int, column: int): void
    }

    class PieceBuilder
    {
        -settlementCost: Resource[*]
        -cityCost: Resource[*]
        -roadCost: Resource[*]
        -developmentDeck: Resource[*]
        +PieceBuilder(board: GameMap, placer: PropertyPlacer, developmentDeck: DevelopmentDeck)
        +buildSettlement(player: Player, intersection: Intersection): void
        +buildCity(player: Player, intersection: Intersection): void
        +buildRoad(player: Player, edge: Edge): void
        +buildDevelopmentCard(player: Player): String
        -hasSufficientResources(player: Player, cost: Resource[*]): boolean
        -removeResource(player: Player, cost: Resource[*]): void
    }
    PieceBuilder --> GameMap: board
    PieceBuilder --> PropertyPlacer: placer
    PieceBuilder --> DevelopmentDeck: developmentDeck
    PieceBuilder --> Player
    PieceBuilder --> Intersection

    class Player
    {
        -resources: Map<Resource, int>
        -settlementCount: int
        -cityCount: int
        -roadCount: int
        -knightCount: int
        -name: String
        +Player(color: PlayerColor)
        +removeResource(resource: Resource, amount: int): void
        +giveResource(resource: Resource, amount: int): void
        +discardHalfResourceHand(): void
        +giveDevelopmentCard(card: DevelopmentCard): void
        +removeDevelopmentCard(card: DevelopmentCard): void
    }
    Player --> DevelopmentCard: developmentCards[*]
    Player --> TurnTracker: turnTracker

    interface Port
    {
        +tradeRatioXto1ForResource(resourceOffering): int
    }

    class PortMap
    {
        ~positionsToPort: HashMap<MapPosition, Port>
        -initializePortPositions(ports: Port[*]): void
        +getPortFromPosition(posToFind: MapPosition): Port
        +addPortsToIntersectionMap(map: IntersectionMap): void
    }
    PortMap --> MapPosition
    PortMap --> Port

    class PropertyPlacer
    {
        +PropertyPlacer(longestRoad: LongestRoad)
        +placeRegularSettlementOnMap(player: Player, gameMap: GameMap, intersection: Intersection): void
        +placeCityOnMap(player: Player, intersection: Intersection): void
        +placeRoadOnMap(player: Player, gameMap: GameMap, edge: Edge): void
    }
    PropertyPlacer --> LongestRoad: longestRoad
    PropertyPlacer --> Player
    PropertyPlacer --> GameMap
    PropertyPlacer --> Intersection

    class ResourceProducer
    {
        +produceResources(map: GameMap, player: TurnTracker, roll: int): void
        +rollDice(): int
        ~produceHex(hex: Hex, map: GameMap, players: TurnTracker): void
        ~produceIntersection(intersection: Intersection, resource: Resource, players: TurnTracker): void
    }
    ResourceProducer --> GameMap
    ResourceProducer --> TurnTracker
    ResourceProducer --> Hex
    ResourceProducer --> Intersection

    class TurnTracker
    {
        ~colors: PlayerColor[4]
        ~currentPlayerIndex: int
        ~isInitialFirstRound: boolean
        +setupPlayers(numPlayers): void
        +promptForPlayerNames(i: int): String
        +setupBeginnerResourcesAndPieces(): void
        +getCurrentPlayer(): Player
        +passInitialTurn(): void
    }
    TurnTracker --> Player: players[*]

    class VictoryPointCalculator
    {
        +VictoryPointCalculator(longestRoad: LongestRoad, largestArmy: LargestArmy)
        +calculateForPlayer(player: Player): int
        +isWinning(player: Player): boolean
    }
    VictoryPointCalculator --> LongestRoad: longestRoad
    VictoryPointCalculator --> LargestArmy: largestArmy
    VictoryPointCalculator --> Player
}

package control
{
    class BuildingHandler
    {
        +BuildingHandler(game: CatanGame, builder: PieceBuilder, handler: InputHandler)
        +placeSettlement(point: Point): void
        +placeCity(point: Point): void
        +placeRoad(point: Point, chargeResources: boolean): void
        +buyDevelopmentCard((hasNotRolled: boolean): void
    }
    BuildingHandler --> CatanGame: catanGame
    BuildingHandler --> PieceBuilder: itemBuilder
    BuildingHandler --> InputHandler: handler

    class CatanGame
    {
        -isFogOfWar: boolean
        ~startGame(): void
        +makeBoard(state: GameStartState, numPlaers: int, gamemode: GameMode, isDebug: boolean): void
        +advancedInitialPlacement(): void
        -customHexPlacement(): void
        +drawScreen(): void
        +drawMap(): void
        +drawPlayers(): void
        +drawSpecialCards(): void
        +endTurn(): void
    }
    CatanGame --> GameBoard: gui
    CatanGame --> InputComponent: input
    CatanGame --> GameMap: model
    CatanGame --> HexPlacer: hexesAndHexNumPlacer
    CatanGame --> PlayerPlacer: playerPlacer
    CatanGame --> TurnTracker: turnTracker
    CatanGame --> GameOptionSelector: options
    CatanGame --> MaritimeTradeManager: maritimeTradeManager
    CatanGame --> InputHandler: inputHandler
    CatanGame --> VictoryPointCalculator: pointCalculator
    CatanGame --> LongestRoad
    CatanGame --> LargestArmy
    CatanGame --> PieceBuilder
    CatanGame --> PropertyPlacer
    CatanGame --> DevelopmentDeck

    class HexPlacer
    {
        -{static}height: int
        -{static}heightOffset: int
        -{static}widthOffset: int
        -{static}leftMin: int
        +HexPlacer(hexes: HexMap)
        +getAllDrawables(): Drawable[*]
        ~getHexDrawable(hexObject: Hex, row: int, col: int): HexGUI
        ~getHexNumDrawable(hexObject: Hex, row: int, col: int): HexNumGUI
        +{static}calculatePosition(row: int, col: int): int[*]
    }
    HexPlacer --> HexMap: hexes
    HexPlacer --> Hex
    HexPlacer --> HexGUI
    HexPlacer --> HexNumGUI

    class InputHandler
    {
        ~hasNotRolled: boolean
        -hexPlacementNumbers: int[*]
        -hexPlacementResources: Resource[*]
        +InputHandler(resourceProducer: ResourceProducer, game: CatanGame, builder: PieceBuilder)
        +buyDevelopmentCard(): void
        +selectAndUseDevCard(): void
        ~playDevelopmentCard(selected: Class): void
        -stealAllOfResource(resource: Resource): void
        +discardCardsForEveryPlayer(): void
        +tradeWithPlayer(): void
        +rollDice(): int
        -moveRobber(): void
        ~selectPlayerToStealFromAtMapPosition(mapPosition: MapPosition): void
        +produceResources(numRolled: int): void
        -stealFromPlayer(selectedPlayerColor: PlayerColor): void
        -offerPlayerTwoFreeRoads(): void
        -giveResourceToCurrentPlayer(resource: Resource): void
        ~updateRobberPositionOnBoard(mousePosition: Point): void
        +endTurn(): void
    }
    InputHandler --> Select1Frame: devCardSelector, resourceNumberSelector, resourceSelector, resourceSelector2
    InputHandler --> Select2Frame: optionalIntersectionSelector, optionalEdgeSelector, mandatoryIntersectionSelector, mandatoryEdgeSelector, hexSelector
    InputHandler --> BuildingHandler: propertyBuilder
    InputHandler --> ResourceProducer: resourceProducer
    InputHandler --> CatanGame: catanGame
    InputHandler --> PieceBuilder

    class MaritimeTradeManager
    {
        +{static} DEFAULT_TRADE_COST: int
        +{static} GENERIC_TRADE_COST: int
        +{static} SPECIAL_TRADE_COST: int
        -soldResource: Resource
        -boughtResource: Resource
        +MaritimeTradeManager(inputHandler: InputHandler, catanGame: CatanGame)
        +trade(): void
        ~sellResource(resource: Resource): void
        ~buyResource(resource: Resource): void
        ~tradeViaPort(portType: PortSelector.PortTypes): void
        ~exchangeResourcesWithBand(tradeCost: int): void
    }
    MaritimeTradeManager --> InputHandler: inputHandler
    MaritimeTradeManager --> CatanGame: catanGame
    MaritimeTradeManager --> ResourceSelector: sellingResourceSelector, buyingResourceSelector
    MaritimeTradeManager --> PortSelector: portSelector

    class PlayerPlacer
    {
        -xPlayerBackground: int
        -yPlayerBackground: int
        -playerBackgroundWidth: int
        -playerBackgroundHeight: int
        ~numberOfPlayers: int
        +PlayerPlacer(turnTracker: TurnTracker)
        +refreshPlayerNumber(): void
        +getAllPlayerGUIs(): Drawable[*]
        +getDevelopmentCardMap(player: Player): HashMap<String, int>
        +getDevelopmentCardMapAmount(player: Player): HashMap<String, int>
    }
    PlayerPlacer --> turnTracker: turnTracker
    PlayerPlacer --> Player
}
@enduml